// =========================================
// Professional PhotoWall v2 - Fixed Version
// =========================================

import React, { useEffect, useMemo, useState, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Columns,
  LayoutGrid,
  Grid,
  List,
  Search,
  Download,
  Trash2,
  Folder,
  FolderPlus,
  Edit3,
  RotateCcw,
  Zap,
  Save,
  Settings
} from 'lucide-react';

// dnd-kit imports
import { DndContext, closestCenter } from '@dnd-kit/core';
import { arrayMove, SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';

export type PhotoWallLayout = 'masonry' | 'grid' | 'columns' | 'list' | 'timeline';

export interface PhotoWallProps {
  source: string;
  type?: 'oss' | 'public';
  initialLayout?: PhotoWallLayout;
  onSelectionChange?: (selected: string[]) => void;
}

function Lightbox({ src, onClose }: { src: string; onClose: () => void }) {
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => e.key === 'Escape' && onClose()
    window.addEventListener('keydown', onKey)
    return () => window.removeEventListener('keydown', onKey)
  }, [onClose])

  return (
    <AnimatePresence>
      {src && (
        <motion.div
          className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          onClick={onClose}
        >
          <motion.img
            src={src}
            alt="preview"
            className="max-w-[90vw] max-h-[90vh] rounded-lg shadow-2xl"
            initial={{ scale: 0.95 }}
            animate={{ scale: 1 }}
            onClick={(e) => e.stopPropagation()}
          />
        </motion.div>
      )}
    </AnimatePresence>
  )
}

function Skeleton() {
  return <div className="w-full h-48 bg-gray-200 animate-pulse rounded-lg" />;
}

// Sortable item wrapper
function SortableItem({ id, children }: { id: string; children: React.ReactNode }) {
  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id });
  const style = {
    transform: CSS.Transform.toString(transform),
    transition
  };
  return (
    <div ref={setNodeRef as any} style={style} {...attributes} {...listeners}>
      {children}
    </div>
  );
}

// Simple Image Editor Component (canvas-based)
function ImageEditor({ src, onClose, onSave }: { src: string; onClose: () => void; onSave: (dataUrl: string) => void }) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null)
  const imgRef = useRef<HTMLImageElement | null>(null)
  const [angle, setAngle] = useState(0)
  const [filter, setFilter] = useState('none')
  const [cropRect, setCropRect] = useState<{ x: number; y: number; w: number; h: number } | null>(null)

  useEffect(() => {
    const img = new Image()
    img.crossOrigin = 'anonymous'
    img.src = src
    img.onload = () => {
      imgRef.current = img
      const c = canvasRef.current
      if (!c) return
      const ctx = c.getContext('2d')!
      // fit canvas
      c.width = img.width
      c.height = img.height
      ctx.drawImage(img, 0, 0)
      setCropRect({ x: 0, y: 0, w: img.width, h: img.height })
    }
  }, [src])

  useEffect(() => {
    const c = canvasRef.current
    const img = imgRef.current
    if (!c || !img) return
    const ctx = c.getContext('2d')!
    // clear
    ctx.save()
    ctx.clearRect(0, 0, c.width, c.height)
    // apply rotation and filter by drawing on an offscreen canvas
    ctx.filter = filter as any
    ctx.translate(c.width / 2, c.height / 2)
    ctx.rotate((angle * Math.PI) / 180)
    ctx.translate(-c.width / 2, -c.height / 2)
    ctx.drawImage(img, 0, 0)
    ctx.restore()
    // crop indicator (optional)
    if (cropRect) {
      ctx.strokeStyle = 'rgba(255,255,255,0.8)'
      ctx.lineWidth = 4
      ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h)
    }
  }, [angle, filter, cropRect])

  function doSave() {
    const c = canvasRef.current
    if (!c) return
    let dataUrl = c.toDataURL('image/jpeg', 0.92)
    // if cropRect smaller than canvas, crop
    if (cropRect) {
      const tmp = document.createElement('canvas')
      tmp.width = cropRect.w
      tmp.height = cropRect.h
      const tctx = tmp.getContext('2d')!
      tctx.drawImage(c, cropRect.x, cropRect.y, cropRect.w, cropRect.h, 0, 0, cropRect.w, cropRect.h)
      dataUrl = tmp.toDataURL('image/jpeg', 0.92)
    }
    onSave(dataUrl)
    onClose()
  }

  return (
    <div className="fixed inset-0 z-60 bg-black/70 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg p-4 max-w-3xl w-full">
        <div className="flex gap-2 items-center mb-2">
          <button className="btn" onClick={() => setAngle((a) => a - 90)} title="Rotate left"><RotateCcw /></button>
          <button className="btn" onClick={() => setAngle((a) => a + 90)} title="Rotate right"><RotateCcw className="rotate-180" /></button>
          <select value={filter} onChange={(e) => setFilter(e.target.value)} className="border rounded px-2 py-1">
            <option value="none">Normal</option>
            <option value="grayscale(1)">Grayscale</option>
            <option value="brightness(1.2)">Brighten</option>
            <option value="contrast(1.2)">Contrast</option>
            <option value="sepia(0.6)">Sepia</option>
          </select>
          <div className="ml-auto flex gap-2">
            <button className="btn" onClick={doSave}><Save /> 保存</button>
            <button className="btn" onClick={onClose}>取消</button>
          </div>
        </div>
        <div className="overflow-auto">
          <canvas ref={canvasRef} className="w-full border rounded" />
        </div>
      </div>
    </div>
  )
}

export default function PhotoWall({ source, type = 'public', initialLayout = 'masonry', onSelectionChange }: PhotoWallProps) {
  const [images, setImages] = useState<string[]>([])
  const [loading, setLoading] = useState(true)
  const [layout, setLayout] = useState<PhotoWallLayout>(initialLayout)
  const [preview, setPreview] = useState('')
  const [query, setQuery] = useState('')
  const [selected, setSelected] = useState<Record<string, boolean>>({})

  const [albums, setAlbums] = useState<Record<string, string[]>>(() => {
    try {
      const raw = localStorage.getItem('photoWallAlbums')
      return raw ? JSON.parse(raw) : { All: [] }
    } catch (e) {
      return { All: [] }
    }
  })
  const [currentAlbum, setCurrentAlbum] = useState<string>('All')
  const [visibleCount, setVisibleCount] = useState<number>(20)
  const [editingSrc, setEditingSrc] = useState<string | null>(null)
  const [showAlbumManager, setShowAlbumManager] = useState(false)

  // load images
  useEffect(() => {
    setLoading(true)
    fetch(`/api/images?dir=${source}&type=${type}`)
      .then((r) => r.json())
      .then((data) => {
        const imgs: string[] = data.images || []
        setImages(imgs)
        setLoading(false)
        // merge into albums All if empty
        setAlbums((prev) => {
          const next = { ...prev }
          if (!next.All || next.All.length === 0) next.All = imgs
          // keep existing albums otherwise
          return next
        })
      })
  }, [source, type])

  // persist albums/ordering to localStorage
  useEffect(() => {
    try {
      localStorage.setItem('photoWallAlbums', JSON.stringify(albums))
    } catch (e) {}
  }, [albums])

  // visible slice + search
  const visible = useMemo(() => {
    const base = albums[currentAlbum] ?? []
    let list = base.slice()
    if (query) list = list.filter((i) => i.toLowerCase().includes(query.toLowerCase()))
    return list.slice(0, visibleCount)
  }, [albums, currentAlbum, query, visibleCount])

  // infinite scroll
  useEffect(() => {
    function onScroll() {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 200) {
        setVisibleCount((v) => v + 10)
      }
    }
    window.addEventListener('scroll', onScroll)
    return () => window.removeEventListener('scroll', onScroll)
  }, [])

  // drag end handler: reorder within current album
  function handleDragEnd(event: any) {
    const { active, over } = event
    if (!over || active.id === over.id) return
    setAlbums((prev) => {
      const list = prev[currentAlbum] ? [...prev[currentAlbum]] : []
      const oldIndex = list.indexOf(String(active.id))
      const newIndex = list.indexOf(String(over.id))
      if (oldIndex === -1 || newIndex === -1) return prev
      const nextList = arrayMove(list, oldIndex, newIndex)
      return { ...prev, [currentAlbum]: nextList }
    })
  }

  function toggleSelect(src: string) {
    setSelected((prev) => {
      const n = { ...prev, [src]: !prev[src] }
      const arr = Object.keys(n).filter((k) => n[k])
      onSelectionChange?.(arr)
      return n
    })
  }

  function clearSelection() {
    setSelected({})
    onSelectionChange?.([])
  }

  function exportSelected() {
    const arr = Object.keys(selected).filter((k) => selected[k])
    const blob = new Blob([JSON.stringify(arr, null, 2)], { type: 'application/json' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = 'selected-images.json'
    a.click()
    URL.revokeObjectURL(url)
  }

  function downloadSelected() {
    const arr = Object.keys(selected).filter((k) => selected[k])
    arr.forEach((url) => {
      const a = document.createElement('a')
      a.href = url
      a.download = ''
      document.body.appendChild(a)
      a.click()
      a.remove()
    })
  }

  // image edit save handler: replace in albums and All
  function handleSaveEdited(newDataUrl: string, src: string) {
    setAlbums((prev) => {
      const next: Record<string, string[]> = {}
      for (const k of Object.keys(prev)) {
        next[k] = prev[k]?.map((s) => (s === src ? newDataUrl : s)) ?? []
      }
      return next
    })
    // also images list
    setImages((prev) => prev.map((s) => (s === src ? newDataUrl : s)))
  }

  // timeline grouping by date (uses fake dates if none)
  const timeline = useMemo(() => {
    const base = albums[currentAlbum] ?? []
    const groups: Record<string, string[]> = {}
    base.forEach((s) => {
      // try extract date from filename like 2025-11-28 or use random placeholder
      const m = s.match(/(\d{4}-\d{2}-\d{2})/)
      const date = (m ? m[1] : new Date().toISOString().slice(0, 10) )|| new Date().toISOString().slice(0, 10)
      if (!groups[date]) groups[date] = []
      groups[date].push(s)
    })
    // sort dates desc
    const ordered = Object.keys(groups).sort((a, b) => (a < b ? 1 : -1)).reduce((acc: any, d) => {
      acc[d] = groups[d]
      return acc
    }, {})
    return ordered as Record<string, string[]>
  }, [albums, currentAlbum])

  // album manager helpers
  function renameAlbum(oldName: string) {
    const name = prompt('重命名相册', oldName)
    if (!name || name === oldName) return
    setAlbums((prev) => {
      const next: Record<string, string[]> = {}
      Object.keys(prev).forEach((k) => {
        if (k === oldName) next[name] = prev[k] ?? []
        else next[k] = prev[k] ?? []  
      })
      return next
    })
    if (currentAlbum === oldName) setCurrentAlbum(name)
  }

  function deleteAlbum(name: string) {
    if (!confirm(`删除相册 ${name} ?`)) return
    setAlbums((prev) => {
      const next = { ...prev }
      delete next[name]
      if (!next.All) next.All = images
      return next
    })
    if (currentAlbum === name) setCurrentAlbum('All')
  }

  function moveSelectedToAlbum(dest: string) {
    const sel = Object.keys(selected).filter((k) => selected[k])
    if (!sel.length) return alert('未选中图片')
    setAlbums((prev) => {
      const next = { ...prev }
      next[dest] = Array.from(new Set([...(next[dest] || []), ...sel]))
      // remove from other albums? keep originals
      return next
    })
    clearSelection()
  }

  return (
    <div className="p-6">
      <div className="flex items-center justify-between mb-4 gap-4 flex-wrap">
        {/* Albums bar + manager */}
        <div className="flex items-center gap-2 mr-4 overflow-auto">
          {Object.keys(albums).map((a) => (
            <button
              key={a}
              onClick={() => {
                setCurrentAlbum(a)
                setVisibleCount(20)
              }}
              className={`px-3 py-1 rounded-full border flex items-center gap-1 ${currentAlbum === a ? 'bg-blue-500 text-white' : 'bg-white'}`}
            >
              <Folder size={14} /> {a}
            </button>
          ))}

          <button
            onClick={() => {
              const name = prompt('新相册名称')
              if (!name) return
              setAlbums((p) => ({ ...p, [name]: [] }))
            }}
            className="px-2 py-1 border rounded-full"
            title="新建相册"
          >
            <FolderPlus size={14} />
          </button>

          <button onClick={() => setShowAlbumManager(true)} className="px-2 py-1 border rounded-full ml-2"><Settings size={14} /></button>
        </div>

        {/* layout buttons */}
        <div className="flex gap-2">
          <button onClick={() => setLayout('masonry')} className="btn"><Columns size={18} /></button>
          <button onClick={() => setLayout('grid')} className="btn"><LayoutGrid size={18} /></button>
          <button onClick={() => setLayout('columns')} className="btn"><Grid size={18} /></button>
          <button onClick={() => setLayout('list')} className="btn"><List size={18} /></button>
          <button onClick={() => setLayout('timeline')} className="btn">Timeline</button>
        </div>

        {/* search + actions */}
        <div className="flex items-center gap-2 ml-auto">
          <div className="relative">
            <input
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              placeholder="搜索..."
              className="pl-10 pr-4 py-2 border rounded-lg"
            />
            <Search className="absolute left-3 top-2.5" size={18} />
          </div>

          <div className="flex gap-2">
            <button onClick={exportSelected} className="btn" title="导出选中"><Download size={16} /></button>
            <button onClick={clearSelection} className="btn" title="清空选择"><Trash2 size={16} /></button>
            <div className="flex items-center gap-2">
              <button onClick={() => moveSelectedToAlbum(prompt('目标相册名称') || '')} className="btn">移动到...</button>
            </div>
          </div>
        </div>
      </div>

      {/* Album Manager Modal */}
      <AnimatePresence>
        {showAlbumManager && (
          <motion.div className="fixed inset-0 z-70 bg-black/60 flex items-center justify-center" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
            <motion.div className="bg-white rounded-lg p-4 w-full max-w-2xl" initial={{ y: 20 }} animate={{ y: 0 }} exit={{ y: 20 }}>
              <h3 className="text-lg font-medium mb-2">相册管理</h3>
              <div className="flex flex-col gap-2">
                {Object.keys(albums).map((a) => (
                  <div key={a} className="flex items-center justify-between border rounded px-2 py-1">
                    <div className="flex items-center gap-2">
                      <Folder size={16} />
                      <div>{a}</div>
                      <div className="text-xs text-gray-500">{(albums[a]?.length ?? 0)} 张</div>
                    </div>
                    <div className="flex gap-2">
                      <button className="btn" onClick={() => renameAlbum(a)}>重命名</button>
                      {a !== 'All' && <button className="btn" onClick={() => deleteAlbum(a)}>删除</button>}
                    </div>
                  </div>
                ))}
              </div>
              <div className="mt-4 flex justify-end gap-2">
                <button className="btn" onClick={() => setShowAlbumManager(false)}>关闭</button>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Content area */}
      {layout === 'timeline' ? (
        <div className="space-y-6">
          {Object.keys(timeline).map((date) => (
            <div key={date}>
              <div className="text-sm text-gray-600 mb-2">{date}</div>
              <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
                {(timeline[date] ?? []).map((src) => (
                  <div key={src} className="rounded-lg overflow-hidden shadow bg-white">
                    <div className="relative">
                      <button
                        onClick={() => toggleSelect(src)}
                        className={`absolute m-2 z-10 px-2 py-1 text-xs rounded-full bg-white/90 border ${selected[src] ? 'ring-2 ring-blue-400' : ''}`}
                      >
                        {selected[src] ? '✓' : '+'}
                      </button>
                      <div onClick={() => setPreview(src)} className="cursor-pointer">
                        <img src={src} alt={src} loading="lazy" className="w-full h-auto" />
                      </div>
                    </div>
                    <div className="p-2 text-xs text-gray-600 truncate">{src.split('/').pop()}</div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      ) : (
        <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
          <SortableContext items={visible} strategy={verticalListSortingStrategy}>
            <div className={
              layout === 'masonry'
                ? 'columns-1 sm:columns-2 md:columns-3 lg:columns-4 gap-4 space-y-4'
                : layout === 'grid'
                ? 'grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4'
                : layout === 'columns'
                ? 'grid grid-cols-3 gap-4'
                : 'flex flex-col gap-6'
            }>
              {loading
                ? Array.from({ length: 8 }).map((_, i) => <Skeleton key={i} />)
                : visible.map((src) => (
                    <SortableItem id={src} key={src}>
                      <motion.div whileHover={{ scale: 1.02 }} className="rounded-xl overflow-hidden shadow bg-white break-inside-avoid relative">
                        <button
                          onClick={() => toggleSelect(src)}
                          className={`absolute m-2 z-10 px-2 py-1 text-xs rounded-full bg-white/90 border ${selected[src] ? 'ring-2 ring-blue-400' : ''}`}
                        >
                          {selected[src] ? '✓' : '+'}
                        </button>

                        <button
                          onClick={(e) => {
                            e.stopPropagation()
                            if (currentAlbum === 'All') return
                            setAlbums((prev) => {
                              const list = prev[currentAlbum] ?? [];
                              return {
                                ...prev,
                                [currentAlbum]: list.includes(src) ? list : [...list, src]
                              };
                            })
                          }}
                          className="absolute top-2 right-2 z-10 bg-white/80 text-xs px-2 py-1 border rounded-full"
                        >
                          + Album
                        </button>

                        <button
                          onClick={(e) => { e.stopPropagation(); setEditingSrc(src) }}
                          className="absolute top-2 right-14 z-10 bg-white/80 text-xs px-2 py-1 border rounded-full"
                          title="编辑"
                        >
                          <Edit3 size={14} />
                        </button>

                        <div onClick={() => setPreview(src)} className="cursor-pointer">
                          <img src={src} alt={src} loading="lazy" className="w-full h-auto" />
                        </div>

                        <div className="p-2 text-xs text-gray-600 truncate">{src.split('/').pop()}</div>
                      </motion.div>
                    </SortableItem>
                  ))}
            </div>
          </SortableContext>
        </DndContext>
      )}

      {preview && <Lightbox src={preview} onClose={() => setPreview('')} />}

      {editingSrc && (
        <ImageEditor
          src={editingSrc}
          onClose={() => setEditingSrc(null)}
          onSave={(d) => handleSaveEdited(d, editingSrc)}
        />
      )}
    </div>
  )
}

// helper export
export function createPhotoWallConfig(config: PhotoWallProps) {
  return config
}
